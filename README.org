* caveman2-widgets
** What is it
caveman2-widgets is an extension library to [[https://github.com/fukamachi/caveman][caveman2]]. It is influenced
by [[https://github.com/skypher/weblocks][Weblocks]] and introduces its widget system for the developer. By
only using its widget concept it does not control the developer as
much as Weblocks itself. For people who don't now Weblocks' aproach:
the developer can create web applications (more) like a normal GUI
application by using subclassable widgets which can have callbacks and
their like. Each Widget is only responsible for its own content but
might interfere with other objects.

** Usage
*** General 
The only important thing is to run the function INIT-WIDGETS with an
<APP>. If you use caveman's MAKE-PROJECT function you will get file
called "src/web.lisp". In this file you can adapt the following:
#+BEGIN_SRC lisp

(defpackage my-caveman2-webapp.web
  (:use :cl
        :caveman2
        :caveman2-widgets ;; easy use of the external symbols of this project
        :my-caveman2-webapp.config
        :my-caveman2-webapp.view
        :my-caveman2-webapp.db
        :datafly
        :sxql)
  (:export :*web*))

;; some other code

;; the following will be generated through MAKE-PROJECT but is very important:
(defclass <web> (<app>) ())
(defvar *web* (make-instance '<web>))
(clear-routing-rules *web*)


;; the neccessary call to initialize the widgets:
(init-widgets *web*)

;; from now on you can do whatever you want
#+END_SRC

*** Global scope
There are two scopes: /global/ and /session/. The global scope
"limits" the widget to *all* users. Therefore if you create a stateful
widget the state will be displayed to all users of your site. We
supplied the method MAKE-WIDGET to generate new widgets. This method
should be used, since it does all the background stuff for you. Use
MAKE-WIDGET with :GLOBAL to get a globally scoped widget.

A very simple example of what you can do with it:
#+BEGIN_SRC lisp
(defclass <global-widget> (<widget>)
  ((enabled
    :initform nil
    :accessor enabled)))

(defmethod render-widget ((this <global-widget>))
  (if (enabled this)
      "<h1>enabled!</h1>"
      "<h1>not enabled</h1>"))

(defmethod render-widget-rest ((this <global-widget>) (method (eql :get)) (args t))
  (render-widget this))

(defvar *global-widget* (make-widget :global '<global-widget>))

(defroute "/" ()
  (render-widget *global-widget*))

(defroute "/disable" ()
  (setf (enabled *global-widget*) nil)
  "disabled it")

(defroute "/enable" ()
  (setf (enabled *global-widget*) t)
  "enabled it")
#+END_SRC

*** Session scope
The other option is to use a /session/ scope. This is a bit more
tricky because all your /session/ widgets must be stored with the
session. :SESSION is the keyword for MAKE-WIDGET to get a /session/
widget. Of course you only need to save the top level (highest) widget
of a widget tree in the session (the children will be saved where the
parent is). A short overview of the functions:
- SET-WIDGET-FOR-SESSION :: Saves a widget in the session
     variable. This should be considered ONLY for session scoped
     widgets.
- GET-WIDGET-FOR-SESSION :: Gets a previously saved widget from the
     session variable (e.g. to render it).
- REMOVE-WIDGET-FOR-SESSION :: Removes a saved widget from the session
     variable.

An example (with children):
#+BEGIN_SRC lisp
(defclass <display-id-widget> (<widget>)
  ())

(defmethod render-widget ((this <display-id-widget>))
  (concatenate 'string
               "<h3>display-id-widget id: <a href=\"/rest/display-id-widget?id="
               (caveman2-widgets.widget::id this)
               "\">"
               (caveman2-widgets.widget::id this)
               "</a></h3>"))

(defclass <session-widget> (<widget>)
  ((id-widget
    :initform (make-widget :session '<display-id-widget>)
    :reader id-widget)))

(defmethod render-widget ((this <session-widget>))
  (concatenate 'string
               "<h1>The id of your widget</h1>"
               "<h2>It should be different for each session</h2>"
               "<p>My id: <a href=\"/rest/session-widget?id="
               (caveman2-widgets.widget::id this)
               "\">"
               (caveman2-widgets.widget::id this)
               "</a></p>"
               (render-widget (id-widget this))))

(defmethod render-widget-rest ((this <session-widget>)
                               (method (eql :get))
                               (args t))
  (render-widget this))


(defroute "/" ()
  (set-widget-for-session :session-widget
                          (make-widget :session '<session-widget>))
  (concatenate 'string
             (render-widget
              (get-widget-for-session :session-widget))
             (render-widget
              (make-button :global
                           "Reset session"
                           #'(lambda ()
                               (remove-widget-for-session :session-widget))))))

(defroute "/reset-session" ()
  (remove-widget-for-session :session-widget)
  "reset your session")
#+END_SRC

** Things that happen automatically
*** Automatically REST API creation
If you create a widget then routes for a REST API will be added
automatically. Suppose you subclass <widget> with the class
"<my-widget>", then you will get the path "/rest/my-widget" which you
can access.

#+BEGIN_SRC lisp
(defclass <my-widget> (<widget>)
  ())

(defmethod render-widget ((this <my-widget>))
  "my-widget representation for the website")

(defmethod render-widget-rest ((this <my-widget>) (method (eql :get)) (args t))
  "my-widget representation for the REST.")

(defmethod render-widget-rest ((this <my-widget>) (method (eql :post)) (args t))
  (render-widget this))
#+END_SRC

*** Encapsulating widgets with divs
Each widget getsw wrapped in a div automatically. Therefore you can
access every widget (and derived widget) very easily with CSS.

** Installation
*** Quicklisp
Clone this repository into "~/quicklisp/local-projects" to QUICKLOAD
it.
*** Roswell
Clone this repository into "~/.roswell/local-projects" to QUICKLOAD
it.
** Author

+ Richard Paul Bäck (richard.baeck@free-your-pc.com)

** Copyright

Copyright (c) 2016 Richard Paul Bäck (richard.baeck@free-your-pc.com)

** License

Licensed under the LLGPL License.
